<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/STATEFLOW_MIGRATION.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/STATEFLOW_MIGRATION.md" />
              <option name="updatedContent" value="# ✅ Migración a StateFlow - Completada&#10;&#10;##  ¿Qué cambió?&#10;&#10;Migré **todos los ViewModels** de usar propiedades mutables (`var`) a usar **StateFlow** para manejar el estado de forma reactiva y siguiendo las mejores prácticas de Clean Architecture.&#10;&#10;---&#10;&#10;##  Cambios por archivo&#10;&#10;### 1. `SelectImageViewModel.kt`&#10;&#10;**Antes:**&#10;```kotlin&#10;var tempImageUri: Uri? = null&#10;    private set&#10;```&#10;&#10;**Ahora:**&#10;```kotlin&#10;private val _tempImageUri = MutableStateFlow&lt;Uri?&gt;(null)&#10;val tempImageUri: StateFlow&lt;Uri?&gt; = _tempImageUri.asStateFlow()&#10;```&#10;&#10;**Beneficios:**&#10;- ✅ Estado reactivo: los composables se recomponen automáticamente cuando cambia&#10;- ✅ Exposición segura: `_tempImageUri` es privado, solo `tempImageUri` es público (read-only)&#10;- ✅ Thread-safe: StateFlow maneja concurrencia automáticamente&#10;&#10;---&#10;&#10;### 2. `ConfirmImageViewModel.kt`&#10;&#10;**Antes:**&#10;```kotlin&#10;val imageUri: Uri? = imageUriString?.toUri()&#10;```&#10;&#10;**Ahora:**&#10;```kotlin&#10;data class ConfirmImageUiState(&#10;    val imageUri: Uri? = null,&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;private val _uiState = MutableStateFlow(ConfirmImageUiState(imageUri = imageUriString?.toUri()))&#10;val uiState: StateFlow&lt;ConfirmImageUiState&gt; = _uiState.asStateFlow()&#10;```&#10;&#10;**Beneficios:**&#10;- ✅ Estado encapsulado: todo el estado de la UI en una sola data class&#10;- ✅ Escalable: cuando agregues loading/error states, ya está preparado&#10;- ✅ Single source of truth: un solo StateFlow para observar&#10;&#10;---&#10;&#10;### 3. `MainViewModel.kt`&#10;&#10;**Antes:**&#10;```kotlin&#10;class MainViewModel : ViewModel() {&#10;    // Sin estado&#10;}&#10;```&#10;&#10;**Ahora:**&#10;```kotlin&#10;data class MainUiState(&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;private val _uiState = MutableStateFlow(MainUiState())&#10;val uiState: StateFlow&lt;MainUiState&gt; = _uiState.asStateFlow()&#10;```&#10;&#10;**Beneficios:**&#10;- ✅ Preparado para el futuro: cuando agregues lógica (ej: cargar user profile), el estado está listo&#10;- ✅ Consistencia: todos los ViewModels siguen el mismo patrón&#10;&#10;---&#10;&#10;### 4. `ConfirmImageScreen.kt`&#10;&#10;**Antes:**&#10;```kotlin&#10;val viewModel: ConfirmImageViewModel = viewModel(factory = factory)&#10;val imageUri = viewModel.imageUri&#10;```&#10;&#10;**Ahora:**&#10;```kotlin&#10;val viewModel: ConfirmImageViewModel = viewModel(factory = factory)&#10;val uiState = viewModel.uiState.collectAsState().value&#10;val imageUri = uiState.imageUri&#10;```&#10;&#10;**Beneficios:**&#10;- ✅ Observación reactiva: `collectAsState()` hace que Compose se recomponga cuando cambia el estado&#10;- ✅ Lifecycle-aware: se desuscribe automáticamente cuando el composable sale de pantalla&#10;&#10;---&#10;&#10;##  Patrón aplicado&#10;&#10;### **StateFlow Pattern**&#10;&#10;```kotlin&#10;// En el ViewModel&#10;private val _state = MutableStateFlow&lt;T&gt;(initialValue)  // ← Privado, mutable&#10;val state: StateFlow&lt;T&gt; = _state.asStateFlow()           // ← Público, read-only&#10;&#10;// Modificar estado (solo desde el ViewModel)&#10;_state.value = newValue&#10;&#10;// En el Composable&#10;val state = viewModel.state.collectAsState().value&#10;```&#10;&#10;---&#10;&#10;##  Próximos pasos (para cuando sigas desarrollando)&#10;&#10;### 1. **Agregar eventos de UI con SharedFlow**&#10;Para eventos one-time (como navegar o mostrar un Toast), usá `SharedFlow`:&#10;&#10;```kotlin&#10;// En el ViewModel&#10;private val _events = Channel&lt;UiEvent&gt;()&#10;val events = _events.receiveAsFlow()&#10;&#10;sealed class UiEvent {&#10;    data class ShowError(val message: String) : UiEvent()&#10;    object NavigateBack : UiEvent()&#10;}&#10;&#10;// Emitir evento&#10;viewModelScope.launch {&#10;    _events.send(UiEvent.ShowError(&quot;Something went wrong&quot;))&#10;}&#10;&#10;// En el Composable&#10;LaunchedEffect(Unit) {&#10;    viewModel.events.collect { event -&gt;&#10;        when (event) {&#10;            is UiEvent.ShowError -&gt; { /* mostrar snackbar */ }&#10;            is UiEvent.NavigateBack -&gt; navController.popBackStack()&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### 2. **Usar viewModelScope para operaciones async**&#10;Cuando agregues llamadas a Firebase/Unsplash:&#10;&#10;```kotlin&#10;fun loadRandomImage() {&#10;    viewModelScope.launch {&#10;        try {&#10;            _uiState.value = _uiState.value.copy(isLoading = true)&#10;            val image = getRandomImageUseCase()&#10;            _uiState.value = _uiState.value.copy(&#10;                isLoading = false,&#10;                imageUri = image&#10;            )&#10;        } catch (e: Exception) {&#10;            _uiState.value = _uiState.value.copy(&#10;                isLoading = false,&#10;                error = e.message&#10;            )&#10;        }&#10;    }&#10;}&#10;```&#10;&#10;### 3. **Migrar a Hilt para DI**&#10;Eliminá las Factories y usá Hilt:&#10;&#10;```kotlin&#10;@HiltViewModel&#10;class SelectImageViewModel @Inject constructor(&#10;    private val createTempImageUriUseCase: CreateTempImageUriUseCase&#10;) : ViewModel() {&#10;    // ...&#10;}&#10;&#10;// En el Composable&#10;@Composable&#10;fun SelectImageScreen(&#10;    viewModel: SelectImageViewModel = hiltViewModel()&#10;) {&#10;    // ...&#10;}&#10;```&#10;&#10;---&#10;&#10;##  Referencias útiles&#10;&#10;- [StateFlow docs](https://developer.android.com/kotlin/flow/stateflow-and-sharedflow)&#10;- [Jetpack Compose State](https://developer.android.com/jetpack/compose/state)&#10;- [Guide to app architecture](https://developer.android.com/topic/architecture)&#10;&#10;---&#10;&#10;## ✅ Checklist de migración&#10;&#10;- [x] `SelectImageViewModel` → StateFlow&#10;- [x] `ConfirmImageViewModel` → StateFlow + UiState&#10;- [x] `MainViewModel` → StateFlow + UiState&#10;- [x] `ConfirmImageScreen` → collectAsState()&#10;- [x] Imports actualizados&#10;- [x] Compilación sin errores&#10;- [ ] `SelectImageScreen` → collectAsState() (opcional, no usa el state aún)&#10;- [ ] Agregar SharedFlow para eventos one-time&#10;- [ ] Migrar a Hilt (reemplazar factories)&#10;- [ ] Tests unitarios para ViewModels&#10;&#10;---&#10;&#10;**¿Tenés dudas?** Cualquier cosa preguntame y te explico más en detalle. &#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/drawmaster/presentation/screens/ConfirmImage.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/drawmaster/presentation/screens/ConfirmImage.kt" />
              <option name="originalContent" value="package com.example.drawmaster.presentation.screens&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.draw.rotate&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.drawmaster.ui.theme.DrawMasterTheme&#10;import com.example.drawmaster.R&#10;import com.example.drawmaster.presentation.components.TextButton&#10;import com.example.drawmaster.ui.theme.LightGray&#10;import com.example.drawmaster.ui.theme.TealBlue&#10;import coil.compose.rememberAsyncImagePainter&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.drawmaster.presentation.viewmodel.ConfirmImageViewModel&#10;import com.example.drawmaster.presentation.viewmodel.ConfirmImageViewModelFactory&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ConfirmImageScreen(&#10;    navController: NavHostController,&#10;    imageUriString: String?,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val factory = remember {&#10;        ConfirmImageViewModelFactory(imageUriString)&#10;    }&#10;    val viewModel: ConfirmImageViewModel = viewModel(factory = factory)&#10;    val uiState = viewModel.uiState.collectAsState().value&#10;    val imageUri = uiState.imageUri&#10;&#10;    Scaffold(&#10;        modifier = modifier,&#10;        topBar = {&#10;            TopAppBar(&#10;                navigationIcon = {&#10;                    IconButton(onClick = { viewModel.onChooseDifferentImageClicked(navController) }) {&#10;                        Image(&#10;                            painter = painterResource(id = R.drawable.arrow),&#10;                            contentDescription = &quot;Go Back&quot;,&#10;                            modifier = Modifier&#10;                                .size(24.dp)&#10;                                .rotate(180f)&#10;                        )&#10;                    }&#10;                },&#10;                title = {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&quot;Select Image&quot;, color = Color.White)&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = TealBlue&#10;                )&#10;            )&#10;        },&#10;        content = { innerPadding -&gt;&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(innerPadding),&#10;                contentAlignment = Alignment.TopCenter&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(16.dp),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Card(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth(0.9f)&#10;                            .height(220.dp),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        colors = CardDefaults.cardColors(containerColor = Color.White)&#10;                    ) {&#10;                        if (imageUri != null) {&#10;                            Image(&#10;                                painter = rememberAsyncImagePainter(model = imageUri),&#10;                                contentDescription = &quot;Selected image from camera&quot;,&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentScale = ContentScale.Fit&#10;                            )&#10;                        } else {&#10;                            // Displaying default image if there is no Uri&#10;                            Image(&#10;                                painter = painterResource(id = R.drawable.mountains),&#10;                                contentDescription = &quot;Placeholder image&quot;,&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentScale = ContentScale.Fit&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .align(Alignment.BottomCenter)&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    TextButton(&#10;                        name = &quot;Start drawing&quot;,&#10;                        backgroundColor = TealBlue,&#10;                        borderColor = TealBlue,&#10;                        fontColor = Color.White,&#10;                        onClick = { viewModel.onStartDrawingClicked(navController) }&#10;                    )&#10;                    TextButton (&#10;                        name = &quot;Choose a different image&quot;,&#10;                        backgroundColor = Color.White,&#10;                        borderColor = LightGray,&#10;                        fontColor = Color.Black,&#10;                        onClick = { viewModel.onChooseDifferentImageClicked(navController) }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;&#10;&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun ConfirmImageScreenPreview() {&#10;    val navController = rememberNavController()&#10;    DrawMasterTheme {&#10;        ConfirmImageScreen(navController = navController, imageUriString = null)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.drawmaster.presentation.screens&#10;&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.runtime.collectAsState&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.remember&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.draw.rotate&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.navigation.NavHostController&#10;import androidx.navigation.compose.rememberNavController&#10;import com.example.drawmaster.ui.theme.DrawMasterTheme&#10;import com.example.drawmaster.R&#10;import com.example.drawmaster.presentation.components.TextButton&#10;import com.example.drawmaster.ui.theme.LightGray&#10;import com.example.drawmaster.ui.theme.TealBlue&#10;import coil.compose.rememberAsyncImagePainter&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.example.drawmaster.presentation.viewmodel.ConfirmImageViewModel&#10;import com.example.drawmaster.presentation.viewmodel.ConfirmImageViewModelFactory&#10;&#10;@OptIn(ExperimentalMaterial3Api::class)&#10;@Composable&#10;fun ConfirmImageScreen(&#10;    navController: NavHostController,&#10;    imageUriString: String?,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val factory = remember {&#10;        ConfirmImageViewModelFactory(imageUriString)&#10;    }&#10;    val viewModel: ConfirmImageViewModel = viewModel(factory = factory)&#10;    val uiState = viewModel.uiState.collectAsState().value&#10;    val imageUri = uiState.imageUri&#10;&#10;    Scaffold(&#10;        modifier = modifier,&#10;        topBar = {&#10;            TopAppBar(&#10;                navigationIcon = {&#10;                    IconButton(onClick = { viewModel.onChooseDifferentImageClicked(navController) }) {&#10;                        Image(&#10;                            painter = painterResource(id = R.drawable.arrow),&#10;                            contentDescription = &quot;Go Back&quot;,&#10;                            modifier = Modifier&#10;                                .size(24.dp)&#10;                                .rotate(180f)&#10;                        )&#10;                    }&#10;                },&#10;                title = {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;                        Text(&quot;Select Image&quot;, color = Color.White)&#10;                    }&#10;                },&#10;                colors = TopAppBarDefaults.topAppBarColors(&#10;                    containerColor = TealBlue&#10;                )&#10;            )&#10;        },&#10;        content = { innerPadding -&gt;&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(innerPadding),&#10;                contentAlignment = Alignment.TopCenter&#10;            ) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .fillMaxSize()&#10;                        .padding(16.dp),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Card(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth(0.9f)&#10;                            .height(220.dp),&#10;                        shape = RoundedCornerShape(12.dp),&#10;                        colors = CardDefaults.cardColors(containerColor = Color.White)&#10;                    ) {&#10;                        if (imageUri != null) {&#10;                            Image(&#10;                                painter = rememberAsyncImagePainter(model = imageUri),&#10;                                contentDescription = &quot;Selected image from camera&quot;,&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentScale = ContentScale.Fit&#10;                            )&#10;                        } else {&#10;                            // Displaying default image if there is no Uri&#10;                            Image(&#10;                                painter = painterResource(id = R.drawable.mountains),&#10;                                contentDescription = &quot;Placeholder image&quot;,&#10;                                modifier = Modifier.fillMaxSize(),&#10;                                contentScale = ContentScale.Fit&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .align(Alignment.BottomCenter)&#10;                        .padding(16.dp),&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    TextButton(&#10;                        name = &quot;Start drawing&quot;,&#10;                        backgroundColor = TealBlue,&#10;                        borderColor = TealBlue,&#10;                        fontColor = Color.White,&#10;                        onClick = { viewModel.onStartDrawingClicked(navController) }&#10;                    )&#10;                    TextButton (&#10;                        name = &quot;Choose a different image&quot;,&#10;                        backgroundColor = Color.White,&#10;                        borderColor = LightGray,&#10;                        fontColor = Color.Black,&#10;                        onClick = { viewModel.onChooseDifferentImageClicked(navController) }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    )&#10;}&#10;&#10;&#10;&#10;&#10;@Preview(showBackground = true)&#10;@Composable&#10;fun ConfirmImageScreenPreview() {&#10;    val navController = rememberNavController()&#10;    DrawMasterTheme {&#10;        ConfirmImageScreen(navController = navController, imageUriString = null)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/drawmaster/presentation/viewmodel/ConfirmImageViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/drawmaster/presentation/viewmodel/ConfirmImageViewModel.kt" />
              <option name="originalContent" value="package com.example.drawmaster.presentation.viewmodel&#10;&#10;import android.net.Uri&#10;import androidx.core.net.toUri&#10;import androidx.lifecycle.ViewModel&#10;import androidx.navigation.NavHostController&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;data class ConfirmImageUiState(&#10;    val imageUri: Uri? = null,&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;class ConfirmImageViewModel(&#10;    imageUriString: String?&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(&#10;        ConfirmImageUiState(&#10;            imageUri = imageUriString?.toUri()&#10;        )&#10;    )&#10;    val uiState: StateFlow&lt;ConfirmImageUiState&gt; = _uiState.asStateFlow()&#10;&#10;    fun onStartDrawingClicked(navController: NavHostController) {&#10;        navController.popBackStack(route = &quot;main_screen&quot;, inclusive = false)&#10;        /*&#10;        val finalUri = _uiState.value.imageUri?.toString()&#10;&#10;        if (finalUri != null) {&#10;            val encodedUri = Uri.encode(finalUri)&#10;            navController.navigate(&quot;drawing_screen/$encodedUri&quot;)&#10;        } else {&#10;            navController.popBackStack()&#10;        }*/&#10;    }&#10;&#10;    fun onChooseDifferentImageClicked(navController: NavHostController) {&#10;        navController.popBackStack()&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.drawmaster.presentation.viewmodel&#10;&#10;import android.net.Uri&#10;import androidx.core.net.toUri&#10;import androidx.lifecycle.ViewModel&#10;import androidx.navigation.NavHostController&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;data class ConfirmImageUiState(&#10;    val imageUri: Uri? = null,&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;class ConfirmImageViewModel(&#10;    imageUriString: String?&#10;) : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(&#10;        ConfirmImageUiState(&#10;            imageUri = imageUriString?.toUri()&#10;        )&#10;    )&#10;    val uiState: StateFlow&lt;ConfirmImageUiState&gt; = _uiState.asStateFlow()&#10;&#10;    fun onStartDrawingClicked(navController: NavHostController) {&#10;        navController.popBackStack(route = &quot;main_screen&quot;, inclusive = false)&#10;        /*&#10;        val finalUri = _uiState.value.imageUri?.toString()&#10;&#10;        if (finalUri != null) {&#10;            val encodedUri = Uri.encode(finalUri)&#10;            navController.navigate(&quot;drawing_screen/$encodedUri&quot;)&#10;        } else {&#10;            navController.popBackStack()&#10;        }*/&#10;    }&#10;&#10;    fun onChooseDifferentImageClicked(navController: NavHostController) {&#10;        navController.popBackStack()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/drawmaster/presentation/viewmodel/MainViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/drawmaster/presentation/viewmodel/MainViewModel.kt" />
              <option name="originalContent" value="package com.example.drawmaster.presentation.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.navigation.NavHostController&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;data class MainUiState(&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;class MainViewModel : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(MainUiState())&#10;    val uiState: StateFlow&lt;MainUiState&gt; = _uiState.asStateFlow()&#10;&#10;    fun onSinglePlayerClicked(navController: NavHostController) {&#10;        navController.navigate(&quot;select_image&quot;)&#10;    }&#10;&#10;    fun onMultiplayerClicked(navController: NavHostController) {&#10;        // navController.navigate(&quot;select_friend&quot;)&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.drawmaster.presentation.viewmodel&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.navigation.NavHostController&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;data class MainUiState(&#10;    val isLoading: Boolean = false,&#10;    val error: String? = null&#10;)&#10;&#10;class MainViewModel : ViewModel() {&#10;&#10;    private val _uiState = MutableStateFlow(MainUiState())&#10;    val uiState: StateFlow&lt;MainUiState&gt; = _uiState.asStateFlow()&#10;&#10;    fun onSinglePlayerClicked(navController: NavHostController) {&#10;        navController.navigate(&quot;select_image&quot;)&#10;    }&#10;&#10;    fun onMultiplayerClicked(navController: NavHostController) {&#10;        // navController.navigate(&quot;select_friend&quot;)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/drawmaster/presentation/viewmodel/SelectImageViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/drawmaster/presentation/viewmodel/SelectImageViewModel.kt" />
              <option name="originalContent" value="package com.example.drawmaster.presentation.viewmodel&#10;&#10;import android.net.Uri&#10;import androidx.lifecycle.ViewModel&#10;import com.example.drawmaster.domain.usecase.CreateTempImageUriUseCase&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;class SelectImageViewModel(&#10;    private val createTempImageUriUseCase: CreateTempImageUriUseCase&#10;) : ViewModel() {&#10;&#10;    private val _tempImageUri = MutableStateFlow&lt;Uri?&gt;(null)&#10;    val tempImageUri: StateFlow&lt;Uri?&gt; = _tempImageUri.asStateFlow()&#10;&#10;    fun generateTempImageUri(): Uri {&#10;        val uri = createTempImageUriUseCase()&#10;        _tempImageUri.value = uri&#10;        return uri&#10;    }&#10;&#10;    fun getConfirmNavigationRoute(success: Boolean): String? {&#10;        return if (success &amp;&amp; _tempImageUri.value != null) {&#10;            val encodedUri = Uri.encode(_tempImageUri.value.toString())&#10;            &quot;confirm_image/$encodedUri&quot;&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.example.drawmaster.presentation.viewmodel&#10;&#10;import android.net.Uri&#10;import androidx.lifecycle.ViewModel&#10;import com.example.drawmaster.domain.usecase.CreateTempImageUriUseCase&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;class SelectImageViewModel(&#10;    private val createTempImageUriUseCase: CreateTempImageUriUseCase&#10;) : ViewModel() {&#10;&#10;    private val _tempImageUri = MutableStateFlow&lt;Uri?&gt;(null)&#10;    val tempImageUri: StateFlow&lt;Uri?&gt; = _tempImageUri.asStateFlow()&#10;&#10;    fun generateTempImageUri(): Uri {&#10;        val uri = createTempImageUriUseCase()&#10;        _tempImageUri.value = uri&#10;        return uri&#10;    }&#10;&#10;    fun getConfirmNavigationRoute(success: Boolean): String? {&#10;        return if (success &amp;&amp; _tempImageUri.value != null) {&#10;            val encodedUri = Uri.encode(_tempImageUri.value.toString())&#10;            &quot;confirm_image/$encodedUri&quot;&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;}&#13;&#10;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>